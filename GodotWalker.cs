using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

class GodotWalker : CSharpSyntaxWalker 
{
    const string INDENT_STRING = "    ";
    int indent = 0;
    int consecutive_line_ends = 2;

    public GodotWalker() : base(SyntaxWalkerDepth.Trivia)
    {
    }

    void print(string format, params Object?[]? args) 
    {
        if (consecutive_line_ends > 0) {
            Console.Write(GetIndent());
        }
        Console.Write(format, args);
        consecutive_line_ends = 0;
    }

    void newline() {
        if (consecutive_line_ends < 2) {
            Console.WriteLine();
        }
        consecutive_line_ends++;
    }

    private string GetIndent()
    {
        return string.Concat(Enumerable.Repeat(INDENT_STRING, indent));
    }

    public override void VisitClassDeclaration(ClassDeclarationSyntax node)
    {
        print("# class {0} {1}", node.Identifier, node.BaseList);
        base.VisitClassDeclaration(node);
        print("# end of class {0}", node.Identifier);
        newline();
    }

    public override void VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
        var typewalker = new GodotTypeWalker();
        typewalker.Visit(node.Type);
        string current_type = typewalker.GetTypeName();
        foreach (var variable in node.Variables) {
            print("var {0} : {1}", variable.Identifier, current_type);
        }
    }

    public override void VisitTrivia(SyntaxTrivia trivia)
    {
        switch (trivia.Kind()) {
            case SyntaxKind.XmlComment: {
                throw new NotSupportedException("XmlComment not supported as we don't know when/if those are generated by the parser.");
            }

            case SyntaxKind.SingleLineCommentTrivia:
            case SyntaxKind.SingleLineDocumentationCommentTrivia:
            case SyntaxKind.MultiLineCommentTrivia:
            case SyntaxKind.MultiLineDocumentationCommentTrivia: {
                string text = trivia.ToFullString();
                foreach (var line in text.Split('\n')) {
                    var foo = line.Trim(' ','\t','/', '*');
                    if (consecutive_line_ends == 0) Console.Write(' ');
                    print("# {0}", foo);
                    newline();
                }
                break;
            }

            case SyntaxKind.EndOfLineTrivia: {
                newline();
                break;
            }
        }
    }

    public override void VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
        string return_type = "";
        if (node.ReturnType.ToString() != "void") {
            var typewalker = new GodotTypeWalker();
            typewalker.Visit(node.ReturnType);
            return_type = " -> " + typewalker.GetTypeName();
        }
        print("def {0}{1}{2}:", node.Identifier, node.ParameterList, return_type);
        indent++;
        base.VisitMethodDeclaration(node);
        indent--;
    }
}

class GodotTypeWalker : CSharpSyntaxWalker {
    const string ERROR = "<err>";
    string type = ERROR;

    public override void VisitIdentifierName(IdentifierNameSyntax node)
    {
        if (type == ERROR) {
            type = node.Identifier.Text;
        } else {
            type += "." + node.Identifier.Text;
        }
        switch (type) {
            case "GameObject": type = "Node"; break;
        }
    }

    public override void VisitPredefinedType(PredefinedTypeSyntax node)
    {
        type = node.Keyword.Text;
    }

    public override void VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
        type = "Array[" + type + "]";
    }

    public string GetTypeName() {
        return type;
    }
}
